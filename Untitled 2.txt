- Ownership
	- Heap-allocated objects normally get deallocated when the stack-allocated reference goes out of scope, except if using special constructs like rc (reference-counted)
	- Except when a type has the copy trait, any passing of the object (assigning to a new binding, passing to the function) will delete the original copy
- References
	- References are normally immutable, meaning the referring object can’t be changed 
	- Borrows can’t last for scope greater than the owner’s (has to do with the lifetime)
	- Only one mutable reference to an object may exist at any time (prevents data races)
- Lifetimes
 - fn bar<'a>(x: &'a i32) {}	// described by the ‘a
	- in a function, indicates the reference is alive for that scope
	- ‘static’ lifetime is for the lifetime of the program


- Slice: &b”100”[..] -
- Reference: &b”100” 
- Array: b”100” - statically allocated